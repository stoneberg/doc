


## department service Dockerfile
FROM openjdk:11
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} department-service.jar
ENTRYPOINT ["java","-jar","/department-service.jar"]


# user service Dockerfile
ARG JDK_VERSION
FROM openjdk:${JDK_VERSION}
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} user-service.jar
ENTRYPOINT ["java","-jar","/user-service.jar"]


# docker-compose.yml
version: '3'
services:
  user:
    container_name: user_service
    build:
      context: ./user-service
      args: 
        JDK_VERSION: 11
      dockerfile: Dockerfile  
    image: dailycodebuffer/user  
    ports:
      - 8081:8081
  department:
    container_name: department_service
    build:
      context: ./department-service
      dockerfile: Dockerfile
    image: dailycodebuffer/department 
    ports:
      - 8083:8082
    links:
      - "user:user_service"  
	  
	  
# docker-compose.override.yml
version: '3'
services:
  department:
    container_name: department_service_new
    image: dailycodebuffer/department_new
    ports:
      - 8084:8082
	  

#########################################################	  
services:
  django:
    links:
      - db
	  
도커 컴포즈 파일 버전 3으로 와서는 links 항목을 사용하지 않더라도 한 네트워크 안에 있는 서비스끼리 서로 통신을 할 수 있기 때문에, 
이 항목을 사용하지 않았습니다. (관련 문서인 Links topic in Networking in Compose도 참고하세요.) 한 네트워크로 선언한 적이 없다고요? 
한 docker-compose.yml 안에 있는 서비스들은 별도로 지정하지 않으면 하나의 네트워크에 속합니다. 
(네트워크와 관련된 더 자세한 내용은 Networking in Compose를 참고하세요.)


도커가 직접 volume을 관리하도록 선언한

version: '3'

# 변경 부분!
volumes:
  django_sample_db_dev: {}   <===== services 레벨에 volumes 선언

services:
  db:
    image: postgres
    volumes:
      # 여기도!
      - django_sample_db_dev:/var/lib/postgresql/data  <===== services 레벨에 선언된 volumes 변수에 연결
    environment:
      ...














